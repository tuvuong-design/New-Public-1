import path from "node:path";
import { prisma } from "../../prisma";
import { tmpdir, rmrf } from "../../utils/fs";
import { CACHE_CONTROL_IMMUTABLE, downloadToFile, uploadFile } from "../../utils/r2io";
import { execCmd } from "../../utils/exec";

export async function trimVideoJob(args: { videoId: string; startSec: number; endSec: number }) {
  const v = await prisma.video.findUnique({ where: { id: args.videoId } });
  if (!v) throw new Error("VIDEO_NOT_FOUND");

  const start = Math.max(0, Math.floor(args.startSec));
  const end = Math.max(start + 1, Math.floor(args.endSec));

  const buildId = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  const work = tmpdir("videoshare-edit-");
  const input = path.join(work, "input");
  const out = path.join(work, "trim.mp4");
  try {
    await downloadToFile(v.sourceKey, input);

    const res = await execCmd("ffmpeg", [
      "-y",
      "-ss",
      String(start),
      "-to",
      String(end),
      "-i",
      input,
      "-c:v",
      "libx264",
      "-preset",
      "veryfast",
      "-crf",
      "23",
      "-c:a",
      "aac",
      "-movflags",
      "+faststart",
      out,
    ]);
    if (res.code !== 0) throw new Error("ffmpeg_trim_failed: " + res.stderr);

    const newKey = `videos/${args.videoId}/source/${buildId}.mp4`;
    await uploadFile(newKey, out, "video/mp4", { cacheControl: CACHE_CONTROL_IMMUTABLE });

    // Update source key; the rest of derived assets will be re-generated by existing pipeline.
    await prisma.video.update({
      where: { id: args.videoId },
      data: { sourceKey: newKey, status: "PROCESSING" },
    });

    return { ok: true, newKey };
  } finally {
    rmrf(work);
  }
}
